import { Component, ElementRef, Input, Renderer2 } from '@angular/core';
import * as ɵngcc0 from '@angular/core';

const _c0 = ["*"];
export class FaStackComponent {
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
    }
    ngOnInit() {
        this.renderer.addClass(this.elementRef.nativeElement, 'fa-stack');
    }
    ngOnChanges(changes) {
        if ('size' in changes) {
            if (changes.size.currentValue != null) {
                this.renderer.addClass(this.elementRef.nativeElement, `fa-${changes.size.currentValue}`);
            }
            if (changes.size.previousValue != null) {
                this.renderer.removeClass(this.elementRef.nativeElement, `fa-${changes.size.previousValue}`);
            }
        }
    }
}
FaStackComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: FaStackComponent, selectors: [["fa-stack"]], factory: function FaStackComponent_Factory(t) { return new (t || FaStackComponent)(ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, inputs: { size: "size" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c0, consts: 1, vars: 0, template: function FaStackComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(FaStackComponent, [{
        type: Component,
        args: [{
                selector: 'fa-stack',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return [{ type: Renderer2 }, { type: ElementRef }]; }, { constructor: [], renderer: [], elementRef: [], ngOnInit: [], ngOnChanges: [], size: [{
            type: Input
        }] });
FaStackComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FaStackComponent.propDecorators = {
    size: [{ type: Input }]
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL0plZmZlcnNvbi9EZXNrdG9wL3Byb3llY3Rvcy9sb3RlcmlhTmFjaW9uYWxFY3VhZG9yL2xvdGVyaWFOYWNpb25hbFdlYkFwcC9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2FuZ3VsYXItZm9udGF3ZXNvbWUvZXNtMjAxNS9zdGFjay9zdGFjay5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxhQU1DIiwiZmlsZSI6InN0YWNrLmNvbXBvbmVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuZXhwb3J0IGNsYXNzIEZhU3RhY2tDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdmYS1zdGFjaycpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmICgnc2l6ZScgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMuc2l6ZS5jdXJyZW50VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIGBmYS0ke2NoYW5nZXMuc2l6ZS5jdXJyZW50VmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5zaXplLnByZXZpb3VzVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIGBmYS0ke2NoYW5nZXMuc2l6ZS5wcmV2aW91c1ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuRmFTdGFja0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZmEtc3RhY2snLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuRmFTdGFja0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuRmFTdGFja0NvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbiJdfQ==