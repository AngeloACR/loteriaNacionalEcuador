import { Component, HostBinding, Input, Optional } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { findIconDefinition, icon, parse, } from '@fortawesome/fontawesome-svg-core';
import { FaConfig } from '../config';
import { FaIconLibrary } from '../icon-library';
import { faWarnIfIconDefinitionMissing } from '../shared/errors/warn-if-icon-html-missing';
import { faWarnIfIconSpecMissing } from '../shared/errors/warn-if-icon-spec-missing';
import { faClassList } from '../shared/utils/classlist.util';
import { faNormalizeIconSpec } from '../shared/utils/normalize-icon-spec.util';
import { FaStackItemSizeDirective } from '../stack/stack-item-size.directive';
import { FaStackComponent } from '../stack/stack.component';
import * as ɵngcc0 from '@angular/core';

const _c0 = [1, "ng-fa-icon"];
export class FaIconComponent {
    constructor(sanitizer, config, iconLibrary, stackItem, stack) {
        this.sanitizer = sanitizer;
        this.config = config;
        this.iconLibrary = iconLibrary;
        this.stackItem = stackItem;
        this.classes = [];
        if (stack != null && stackItem == null) {
            console.error('FontAwesome: fa-icon and fa-duotone-icon elements must specify stackItemSize attribute when wrapped into ' +
                'fa-stack. Example: <fa-icon stackItemSize="2x"></fa-icon>.');
        }
    }
    ngOnChanges(changes) {
        if (this.icon == null && this.config.fallbackIcon == null) {
            return faWarnIfIconSpecMissing();
        }
        let iconToBeRendered = null;
        if (this.icon == null) {
            iconToBeRendered = this.config.fallbackIcon;
        }
        else {
            iconToBeRendered = this.icon;
        }
        if (changes) {
            const iconDefinition = this.findIconDefinition(iconToBeRendered);
            if (iconDefinition != null) {
                const params = this.buildParams();
                this.renderIcon(iconDefinition, params);
            }
        }
    }
    /**
     * Programmatically trigger rendering of the icon.
     *
     * This method is useful, when creating {@link FaIconComponent} dynamically or
     * changing its inputs programmatically as in these cases icon won't be
     * re-rendered automatically.
     */
    render() {
        this.ngOnChanges({});
    }
    findIconDefinition(i) {
        const lookup = faNormalizeIconSpec(i, this.config.defaultPrefix);
        if ('icon' in lookup) {
            return lookup;
        }
        const definition = this.iconLibrary.getIconDefinition(lookup.prefix, lookup.iconName);
        if (definition != null) {
            return definition;
        }
        const globalDefinition = findIconDefinition(lookup);
        if (globalDefinition != null) {
            const message = 'Global icon library is deprecated. ' +
                'Consult https://github.com/FortAwesome/angular-fontawesome/blob/master/UPGRADING.md ' +
                'for the migration instructions.';
            if (this.config.globalLibrary === 'unset') {
                console.error('FontAwesome: ' + message);
            }
            else if (!this.config.globalLibrary) {
                throw new Error(message);
            }
            return globalDefinition;
        }
        faWarnIfIconDefinitionMissing(lookup);
        return null;
    }
    buildParams() {
        const classOpts = {
            flip: this.flip,
            spin: this.spin,
            pulse: this.pulse,
            border: this.border,
            inverse: this.inverse,
            size: this.size || null,
            pull: this.pull || null,
            rotate: this.rotate || null,
            fixedWidth: typeof this.fixedWidth === 'boolean' ? this.fixedWidth : this.config.fixedWidth,
            stackItemSize: this.stackItem != null ? this.stackItem.stackItemSize : null,
        };
        const parsedTransform = typeof this.transform === 'string' ? parse.transform(this.transform) : this.transform;
        return {
            title: this.title,
            transform: parsedTransform,
            classes: [...faClassList(classOpts), ...this.classes],
            mask: this.mask != null ? this.findIconDefinition(this.mask) : null,
            styles: this.styles != null ? this.styles : {},
            symbol: this.symbol,
            attributes: {
                role: this.a11yRole,
            },
        };
    }
    renderIcon(definition, params) {
        const renderedIcon = icon(definition, params);
        this.renderedIconHTML = this.sanitizer.bypassSecurityTrustHtml(renderedIcon.html.join('\n'));
    }
}
FaIconComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: FaIconComponent, selectors: [["fa-icon"]], factory: function FaIconComponent_Factory(t) { return new (t || FaIconComponent)(ɵngcc0.ɵɵdirectiveInject(DomSanitizer), ɵngcc0.ɵɵdirectiveInject(FaConfig), ɵngcc0.ɵɵdirectiveInject(FaIconLibrary), ɵngcc0.ɵɵdirectiveInject(FaStackItemSizeDirective, 8), ɵngcc0.ɵɵdirectiveInject(FaStackComponent, 8)); }, hostBindings: function FaIconComponent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(2);
        ɵngcc0.ɵɵelementHostAttrs(_c0);
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("innerHTML", ctx.renderedIconHTML, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵattribute("title", ctx.title);
    } }, inputs: { classes: "classes", icon: "icon", title: "title", spin: "spin", pulse: "pulse", mask: "mask", styles: "styles", flip: "flip", size: "size", pull: "pull", border: "border", inverse: "inverse", symbol: "symbol", rotate: "rotate", fixedWidth: "fixedWidth", transform: "transform", a11yRole: "a11yRole" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], consts: 0, vars: 0, template: function FaIconComponent_Template(rf, ctx) { }, encapsulation: 2 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(FaIconComponent, [{
        type: Component,
        args: [{
                selector: 'fa-icon',
                template: ``,
                host: {
                    class: 'ng-fa-icon',
                    '[attr.title]': 'title'
                }
            }]
    }], function () { return [{ type: DomSanitizer }, { type: FaConfig }, { type: FaIconLibrary }, { type: FaStackItemSizeDirective, decorators: [{
                type: Optional
            }] }, { type: FaStackComponent, decorators: [{
                type: Optional
            }] }]; }, { constructor: [], sanitizer: [], config: [], iconLibrary: [], stackItem: [], classes: [{
            type: Input
        }], ngOnChanges: [], render: [], findIconDefinition: [], buildParams: [], renderIcon: [], renderedIconHTML: [{
            type: HostBinding,
            args: ['innerHTML']
        }], icon: [{
            type: Input
        }], title: [{
            type: Input
        }], spin: [{
            type: Input
        }], pulse: [{
            type: Input
        }], mask: [{
            type: Input
        }], styles: [{
            type: Input
        }], flip: [{
            type: Input
        }], size: [{
            type: Input
        }], pull: [{
            type: Input
        }], border: [{
            type: Input
        }], inverse: [{
            type: Input
        }], symbol: [{
            type: Input
        }], rotate: [{
            type: Input
        }], fixedWidth: [{
            type: Input
        }], transform: [{
            type: Input
        }], a11yRole: [{
            type: Input
        }] });
FaIconComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: FaConfig },
    { type: FaIconLibrary },
    { type: FaStackItemSizeDirective, decorators: [{ type: Optional }] },
    { type: FaStackComponent, decorators: [{ type: Optional }] }
];
FaIconComponent.propDecorators = {
    icon: [{ type: Input }],
    title: [{ type: Input }],
    spin: [{ type: Input }],
    pulse: [{ type: Input }],
    mask: [{ type: Input }],
    styles: [{ type: Input }],
    flip: [{ type: Input }],
    size: [{ type: Input }],
    pull: [{ type: Input }],
    border: [{ type: Input }],
    inverse: [{ type: Input }],
    symbol: [{ type: Input }],
    rotate: [{ type: Input }],
    fixedWidth: [{ type: Input }],
    classes: [{ type: Input }],
    transform: [{ type: Input }],
    a11yRole: [{ type: Input }],
    renderedIconHTML: [{ type: HostBinding, args: ['innerHTML',] }]
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL0plZmZlcnNvbi9EZXNrdG9wL3Byb3llY3Rvcy9sb3RlcmlhTmFjaW9uYWxFY3VhZG9yL2xvdGVyaWFOYWNpb25hbFdlYkFwcC9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2FuZ3VsYXItZm9udGF3ZXNvbWUvZXNtMjAxNS9pY29uL2ljb24uY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdHQyxhQVVDIiwiZmlsZSI6Imljb24uY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IGZpbmRJY29uRGVmaW5pdGlvbiwgaWNvbiwgcGFyc2UsIH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZvbnRhd2Vzb21lLXN2Zy1jb3JlJztcbmltcG9ydCB7IEZhQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IEZhSWNvbkxpYnJhcnkgfSBmcm9tICcuLi9pY29uLWxpYnJhcnknO1xuaW1wb3J0IHsgZmFXYXJuSWZJY29uRGVmaW5pdGlvbk1pc3NpbmcgfSBmcm9tICcuLi9zaGFyZWQvZXJyb3JzL3dhcm4taWYtaWNvbi1odG1sLW1pc3NpbmcnO1xuaW1wb3J0IHsgZmFXYXJuSWZJY29uU3BlY01pc3NpbmcgfSBmcm9tICcuLi9zaGFyZWQvZXJyb3JzL3dhcm4taWYtaWNvbi1zcGVjLW1pc3NpbmcnO1xuaW1wb3J0IHsgZmFDbGFzc0xpc3QgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMvY2xhc3NsaXN0LnV0aWwnO1xuaW1wb3J0IHsgZmFOb3JtYWxpemVJY29uU3BlYyB9IGZyb20gJy4uL3NoYXJlZC91dGlscy9ub3JtYWxpemUtaWNvbi1zcGVjLnV0aWwnO1xuaW1wb3J0IHsgRmFTdGFja0l0ZW1TaXplRGlyZWN0aXZlIH0gZnJvbSAnLi4vc3RhY2svc3RhY2staXRlbS1zaXplLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBGYVN0YWNrQ29tcG9uZW50IH0gZnJvbSAnLi4vc3RhY2svc3RhY2suY29tcG9uZW50JztcbmV4cG9ydCBjbGFzcyBGYUljb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHNhbml0aXplciwgY29uZmlnLCBpY29uTGlicmFyeSwgc3RhY2tJdGVtLCBzdGFjaykge1xuICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuaWNvbkxpYnJhcnkgPSBpY29uTGlicmFyeTtcbiAgICAgICAgdGhpcy5zdGFja0l0ZW0gPSBzdGFja0l0ZW07XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IFtdO1xuICAgICAgICBpZiAoc3RhY2sgIT0gbnVsbCAmJiBzdGFja0l0ZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRm9udEF3ZXNvbWU6IGZhLWljb24gYW5kIGZhLWR1b3RvbmUtaWNvbiBlbGVtZW50cyBtdXN0IHNwZWNpZnkgc3RhY2tJdGVtU2l6ZSBhdHRyaWJ1dGUgd2hlbiB3cmFwcGVkIGludG8gJyArXG4gICAgICAgICAgICAgICAgJ2ZhLXN0YWNrLiBFeGFtcGxlOiA8ZmEtaWNvbiBzdGFja0l0ZW1TaXplPVwiMnhcIj48L2ZhLWljb24+LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaWNvbiA9PSBudWxsICYmIHRoaXMuY29uZmlnLmZhbGxiYWNrSWNvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFXYXJuSWZJY29uU3BlY01pc3NpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWNvblRvQmVSZW5kZXJlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmljb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWNvblRvQmVSZW5kZXJlZCA9IHRoaXMuY29uZmlnLmZhbGxiYWNrSWNvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGljb25Ub0JlUmVuZGVyZWQgPSB0aGlzLmljb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGljb25EZWZpbml0aW9uID0gdGhpcy5maW5kSWNvbkRlZmluaXRpb24oaWNvblRvQmVSZW5kZXJlZCk7XG4gICAgICAgICAgICBpZiAoaWNvbkRlZmluaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuYnVpbGRQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckljb24oaWNvbkRlZmluaXRpb24sIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbW1hdGljYWxseSB0cmlnZ2VyIHJlbmRlcmluZyBvZiB0aGUgaWNvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCwgd2hlbiBjcmVhdGluZyB7QGxpbmsgRmFJY29uQ29tcG9uZW50fSBkeW5hbWljYWxseSBvclxuICAgICAqIGNoYW5naW5nIGl0cyBpbnB1dHMgcHJvZ3JhbW1hdGljYWxseSBhcyBpbiB0aGVzZSBjYXNlcyBpY29uIHdvbid0IGJlXG4gICAgICogcmUtcmVuZGVyZWQgYXV0b21hdGljYWxseS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMubmdPbkNoYW5nZXMoe30pO1xuICAgIH1cbiAgICBmaW5kSWNvbkRlZmluaXRpb24oaSkge1xuICAgICAgICBjb25zdCBsb29rdXAgPSBmYU5vcm1hbGl6ZUljb25TcGVjKGksIHRoaXMuY29uZmlnLmRlZmF1bHRQcmVmaXgpO1xuICAgICAgICBpZiAoJ2ljb24nIGluIGxvb2t1cCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5pY29uTGlicmFyeS5nZXRJY29uRGVmaW5pdGlvbihsb29rdXAucHJlZml4LCBsb29rdXAuaWNvbk5hbWUpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnbG9iYWxEZWZpbml0aW9uID0gZmluZEljb25EZWZpbml0aW9uKGxvb2t1cCk7XG4gICAgICAgIGlmIChnbG9iYWxEZWZpbml0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnR2xvYmFsIGljb24gbGlicmFyeSBpcyBkZXByZWNhdGVkLiAnICtcbiAgICAgICAgICAgICAgICAnQ29uc3VsdCBodHRwczovL2dpdGh1Yi5jb20vRm9ydEF3ZXNvbWUvYW5ndWxhci1mb250YXdlc29tZS9ibG9iL21hc3Rlci9VUEdSQURJTkcubWQgJyArXG4gICAgICAgICAgICAgICAgJ2ZvciB0aGUgbWlncmF0aW9uIGluc3RydWN0aW9ucy4nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmdsb2JhbExpYnJhcnkgPT09ICd1bnNldCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGb250QXdlc29tZTogJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29uZmlnLmdsb2JhbExpYnJhcnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsRGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBmYVdhcm5JZkljb25EZWZpbml0aW9uTWlzc2luZyhsb29rdXApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYnVpbGRQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzT3B0cyA9IHtcbiAgICAgICAgICAgIGZsaXA6IHRoaXMuZmxpcCxcbiAgICAgICAgICAgIHNwaW46IHRoaXMuc3BpbixcbiAgICAgICAgICAgIHB1bHNlOiB0aGlzLnB1bHNlLFxuICAgICAgICAgICAgYm9yZGVyOiB0aGlzLmJvcmRlcixcbiAgICAgICAgICAgIGludmVyc2U6IHRoaXMuaW52ZXJzZSxcbiAgICAgICAgICAgIHNpemU6IHRoaXMuc2l6ZSB8fCBudWxsLFxuICAgICAgICAgICAgcHVsbDogdGhpcy5wdWxsIHx8IG51bGwsXG4gICAgICAgICAgICByb3RhdGU6IHRoaXMucm90YXRlIHx8IG51bGwsXG4gICAgICAgICAgICBmaXhlZFdpZHRoOiB0eXBlb2YgdGhpcy5maXhlZFdpZHRoID09PSAnYm9vbGVhbicgPyB0aGlzLmZpeGVkV2lkdGggOiB0aGlzLmNvbmZpZy5maXhlZFdpZHRoLFxuICAgICAgICAgICAgc3RhY2tJdGVtU2l6ZTogdGhpcy5zdGFja0l0ZW0gIT0gbnVsbCA/IHRoaXMuc3RhY2tJdGVtLnN0YWNrSXRlbVNpemUgOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJzZWRUcmFuc2Zvcm0gPSB0eXBlb2YgdGhpcy50cmFuc2Zvcm0gPT09ICdzdHJpbmcnID8gcGFyc2UudHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtKSA6IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHBhcnNlZFRyYW5zZm9ybSxcbiAgICAgICAgICAgIGNsYXNzZXM6IFsuLi5mYUNsYXNzTGlzdChjbGFzc09wdHMpLCAuLi50aGlzLmNsYXNzZXNdLFxuICAgICAgICAgICAgbWFzazogdGhpcy5tYXNrICE9IG51bGwgPyB0aGlzLmZpbmRJY29uRGVmaW5pdGlvbih0aGlzLm1hc2spIDogbnVsbCxcbiAgICAgICAgICAgIHN0eWxlczogdGhpcy5zdHlsZXMgIT0gbnVsbCA/IHRoaXMuc3R5bGVzIDoge30sXG4gICAgICAgICAgICBzeW1ib2w6IHRoaXMuc3ltYm9sLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIHJvbGU6IHRoaXMuYTExeVJvbGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXJJY29uKGRlZmluaXRpb24sIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZW5kZXJlZEljb24gPSBpY29uKGRlZmluaXRpb24sIHBhcmFtcyk7XG4gICAgICAgIHRoaXMucmVuZGVyZWRJY29uSFRNTCA9IHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RIdG1sKHJlbmRlcmVkSWNvbi5odG1sLmpvaW4oJ1xcbicpKTtcbiAgICB9XG59XG5GYUljb25Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2ZhLWljb24nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYCxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnbmctZmEtaWNvbicsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci50aXRsZV0nOiAndGl0bGUnLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuRmFJY29uQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRG9tU2FuaXRpemVyIH0sXG4gICAgeyB0eXBlOiBGYUNvbmZpZyB9LFxuICAgIHsgdHlwZTogRmFJY29uTGlicmFyeSB9LFxuICAgIHsgdHlwZTogRmFTdGFja0l0ZW1TaXplRGlyZWN0aXZlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9LFxuICAgIHsgdHlwZTogRmFTdGFja0NvbXBvbmVudCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcbkZhSWNvbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBpY29uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0aXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3BpbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcHVsc2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1hc2s6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0eWxlczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmxpcDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcHVsbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYm9yZGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpbnZlcnNlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzeW1ib2w6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJvdGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZml4ZWRXaWR0aDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2xhc3NlczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdHJhbnNmb3JtOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhMTF5Um9sZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVuZGVyZWRJY29uSFRNTDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnaW5uZXJIVE1MJyxdIH1dXG59O1xuIl19